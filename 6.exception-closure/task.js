// Напишите функцию parseCount

// Аргументом функции является значение, которое необходимо распарсить.
// Для парсинга воспользуйтесь функцией Number.parseInt.
// Если результатом парсинга является значение NaN, то выбрасывайте исключение
//  с ошибкой "Невалидное значение".
// Верните результат парсинга из функции.

// Напишите функцию validateCount
// Аргументом функции является значение, которое необходимо распарсить.
// Попробуйте распарсить значение с помощью функции parseCount.
// Если распарсить удаётся успешно, то возвращайте результат.
// Перехватывайте исключение, которое может выбрасывать функция parseCount.
// Возвращайте ошибку из функции в случае перехвата исключения.

"use strict"

function parseCount(parse) {
    let numberOwn = Number.parseInt(parse);
    if(Number.isNaN(numberOwn)) {
        throw new Error('Невалидное значение');
    }
    return numberOwn;
}

function validateCount(parse) {
    try {
        return parseCount(parse);
    } catch (error) {
        return error;
    }
}


// Напишите класс Triangle
// Конструктор класса должен принимать 3 стороны треугольника.
// В случае нарушения правила существования треугольника (сумма двух сторон меньше третьей)
// выбрасывайте исключение с ошибкой "Треугольник с такими сторонами не существует".
// Метод getPerimeter должен возвращать периметр треугольника.
// Метод getArea должен возвращать площадь треугольника (для подсчёта площади воспользуйтесь
// формулой Герона). Точность должна вычисляться с точностью до трёх знаков после запятой.
// Напишите функцию getTriangle
// Аргументами функции являются 3 значения длин сторон.
// Попытайтесь вернуть новый объект треугольника.
// В случае перехвата исключения возвращайте объект с двумя методами getArea
// и getPerimeter, которые возвращают строку: "Ошибка! Треугольник не существует".

"use strict"

class Triangle {
    constructor(a, b, c) {
        if ((b + c < a) || (a + c < b) || (b + a < c)) {
            throw new Error("Треугольник с такими сторонами не существует");
        }

        this.a = a;
        this.b = b;
        this.c = c;
    }

    getPerimeter() {
        return this.a + this.b + this.c;
    }

    getArea() {
        let hp = this.getPerimeter() / 2;

        return +Math.sqrt(hp * (hp - this.a) * (hp - this.b) * (hp - this.c)).toFixed(3);
    }
}

function getTriangle(a, b, c) {
    try {
        return new Triangle(a, b, c);
    } catch (error) {
        return {
            'getArea' : function() {
                return "Ошибка! Треугольник не существует";
            },
            'getPerimeter' : function() {
                return "Ошибка! Треугольник не существует";
            },
        }
    }
}